<p><!DOCTYPE html>
<html>
<title>Redes de Computadores 2 - Prof. Ricardo da Rocha</title></p>

<p><xmp theme="simplex" style="display:none;"></p>

<h1>LaboratÃÂ³rio: ImplementaÃÂ§ÃÂ£o de Protocolo com Sockets TCP em Python</h1>

<h1>Objetivos</h1>

<ul>
<li>ReforÃÂ§ar a compreensÃÂ£o do conceito de sockets como primitiva de comunicaÃÂ§ÃÂ£o na rede</li>
<li>Compreender as chamadas de sistema do SO para manipulaÃÂ§ÃÂ£o de sockets e suas consequÃÂªncias</li>
<li>Compreender como as chamadas de sistema para sockets podem ser mapeadas para construÃÂ§ÃÂµes de software (em APIs)</li>
<li>Compreender a estrutura bÃÂ¡sica de um programa baseado em sockets.</li>
<li>Ter uma visÃÂ£o geral da API de manipulaÃÂ§ÃÂ£o de sockets do Python</li>
<li>Ter uma compreensÃÂ£o inicial sobre a construÃÂ§ÃÂ£o de protocolos e os problemas envolvidos (incluindo problemas de comunicaÃÂ§ÃÂ£o)</li>
</ul>

<h1>VisÃÂ£o Geral</h1>

<p>Neste laboratÃÂ³rio vocÃÂª irÃÂ¡ construir programas simples em Python ou Java para se comportarem como cliente e servidor TCP. </p>

<p>Este laboratÃÂ³rio poderÃÂ¡ ser realizado na linguagem de sua preferÃÂªncia. HÃÂ¡ informaÃÂ§ÃÂµes e cÃÂ³digos de referÃÂªncia em Python e am Java para ajudÃÂ¡-lo no desenvolvimento. Por questÃÂµes didÃÂ¡tica, utilizaremos Python para apresentar o conteÃÂºdo. </p>

<p>Neste laboratÃÂ³rio nÃÂ³s implementaremos o protocolo de um simples servidor de banco de dados, usando sockets TCP.</p>

<h1>Recursos</h1>

<p>Utilizaremos o <code>netstat</code> e o <code>netcat</code> (<code>nc</code>) como ferramentas auxiliares.</p>

<p>HÃÂ¡ uma documentaÃÂ§ÃÂ£o bem resumida e superficial sobre as chamadas oferecidas no mÃÂ³dulo <code>socket</code> em: <a href="http://www.inf.ufg.br/~ricardo/python/programacao.sockets.html">http://www.inf.ufg.br/~ricardo/python/programacao.sockets.html</a></p>

<h2>Slides</h2>

<ul>
<li><a href="SOCKETS.TCP.PYTHON.pdf">Slides utilizados no laboratÃÂ³rio</a> pelo professor.</li>
</ul>

<h2>CÃÂ³digos e Snippets de CÃÂ³digo</h2>

<h3>CÃÂ³digo de ReferÃÂªncia para cliente e servidor TCP em Java</h3>

<ul>
<li>CÃÂ³digo do <a href="codigo/java-sock-protocol.zip">Cliente e servidor TCP trivial</a>, ilustrado nos slides.</li>
<li>Exemplo Python deve ser retirado diretamente dos slides</li>
</ul>

<h3>ManipulaÃÂ§ÃÂ£o de JSON em Java e Python</h3>

<ul>
<li><p><strong>Python</strong> - Uso de JSON em Python: <a href="https://docs.python-guide.org/scenarios/json/">1</a>, <a href="https://realpython.com/python-json/">2</a>. Exemplo de carga do json:</p>

<pre><code>import json


arq = open('dados/banco.json')
bd = json.load(arq)
</code></pre></li>
<li><p><strong>Java</strong> - HÃÂ¡ uma sÃÂ©rie de bibliotecas para manipulaÃÂ§ÃÂ£o de JSON em Java, que podem ser encontradas em <a href="http://json.org/json-pt.html">http://json.org/json-pt.html</a>.</p></li>
</ul>

<h3>Leitura de Strings terminadas com nova linha em Python</h3>

<p>Duas alternativas de cÃÂ³digo para ler strings terminadas com <code>\n</code> em conexÃÂµes:</p>

<ul>
<li><p><a href="http://stackoverflow.com/questions/29023885/python-socket-readline-without-socket-makefile">Snippet 1</a></p>

<pre><code>import StringIO


buff = StringIO.StringIO(2048)
while True:
    data = sock.recv()
    buff.write(data)
    if '\n' in data: break


# Get the buffer data, split it over newlines, print the first line
print buff.getvalue().splitlines()[0]
</code></pre></li>
<li><p><a href="https://synack.me/blog/using-python-tcp-sockets">Snippet 2</a></p>

<pre><code>def readlines(sock, recv_buffer=4096, delim='\n'):
    buffer = ''
    data = True
    while data:
        data = sock.recv(recv_buffer)
        buffer += data      
        while buffer.find(delim) != -1:
            line, buffer = buffer.split('\n', 1)
            yield line
    return
</code></pre></li>
</ul>

<h2>Softwares</h2>

<ul>
<li>MÃÂ¡quina Virtual utilizada nos experimentos, inclui o sistema <code>mininet</code> (ver em <a href="https://github.com/mininet/mininet/wiki/Mininet-VM-Images">mininet.org</a>).</li>
<li><p><strong><code>netstat</code></strong>: ferramenta para verificaÃÂ§ÃÂ£o das conexÃÂµes TCP e UDP.
OpÃÂ§ÃÂµes no Linux</p>

<pre><code>-t : sockets TCP
-u : sockets UDP
-n : exibe o valor numÃÂ©rico das portas
-l : sockets esperando conexÃÂµes (ouvindo)
-c : atualiza continuamente o estado dos sockets
</code></pre>

<p><a href="http://pt.wikipedia.org/wiki/Netstat">OpÃÂ§ÃÂµes no Windows</a> (ou utilize a opÃÂ§ÃÂ£o /?)</p></li>
<li><p><strong><code>nc</code></strong> (<code>netcat</code>): ferramenta de propÃÂ³sito gerar para criaÃÂ§ÃÂ£o de sockets UDP e TCP para comunicaÃÂ§ÃÂ£o.
OpÃÂ§ÃÂµes utilizadas neste laboratÃÂ³rio</p>

<pre><code>-t : sockets TCP
-u : sockets UDP
-n : valor numÃÂ©rico das portas
-l : sockets esperando conexÃÂµes (ouvindo)
-c : atualiza continuamente o estado dos sockets
</code></pre>

<p>Exemplos de uso: </p>

<ul>
<li>Servidor: <code>nc -l 8888</code>: cria um socket servidor TCP ouvindo na porta 8888</li>
<li>Servidor: <code>nc -kl 8888</code>: mesmo que o anterior, mas se mantÃÂ©m ouvindo novas conexÃÂµes apÃÂ³s o tÃÂ©rmino da primeira</li>
<li>Servidor: <code>nc -ul 8888</code>: cria um socket servidor UDP ouvindo na porta 8888</li>
<li>Cliente: <code>nc  127.0.0.1 8888</code>: estabelece uma conexÃÂ£o TCP com o socket servidor no IP <code>127.0.0.1</code>, ouvindo na porta <code>8888</code>.</li>
<li>Cliente: <code>nc -u 127.0.0.1 8888</code>: envia pacotes UDP por sockets cliente UDP para o servidor no IP <code>127.0.0.1</code> na porta <code>8888</code>.</li>
</ul></li>
</ul>

<h1>Atividades do LaboratÃÂ³rio</h1>

<p>Neste laboratÃÂ³rio, nÃÂ³s implementaremos o protocolo de um simples servidor de banco de dados, que mantÃÂ©m os seus dados em <a href="https://pt.wikipedia.org/wiki/JSON">JSON</a>. O nosso banco de teste conterÃÂ¡ os resultados de uma consulta ao <a href="https://dadosabertos.camara.leg.br/swagger/api.html">serviÃÂ§o de dados abertos</a> da CÃÂ¢mara de Deputados, contendo dados sobre os deputados da atual legislatura. O JSON abaixo mostra um trecho do banco de dados usado.</p>

<pre><code>    {
        "dados": [
            {
                "id": 178957,
                "idLegislatura": 55,
                "nome": "ABEL MESQUITA JR.",
                "siglaPartido": "DEM",
                "siglaUf": "RR",
                "uri": "https://dadosabertos.camara.leg.br/api/v2/deputados/178957",
                "uriPartido": "https://dadosabertos.camara.leg.br/api/v2/partidos/36769",
                "urlFoto": "http://www.camara.leg.br/internet/deputado/bandep/178957.jpg"
            },
            ...
    }
</code></pre>

<p>O arquivo abaixo, contÃÂ©m o banco de dados que usaremos nesse laboratÃÂ³rio:</p>

<ul>
<li><a href="dados/banco.json">JSON de deputados da cÃÂ¢mara</a></li>
</ul>

<p>VocÃÂª deverÃÂ¡ implementar um servidor (mantÃÂ©m o socket servidor do servidor de banco de dados) que permitirÃÂ¡ consultas nesse JSON, permitindo pesquisar:</p>

<ul>
<li>Campos do json</li>
<li>Valores armazenados</li>
<li>Pesquisa por wildcards</li>
</ul>

<p>O protocolo sugerido para o servidor ÃÂ© o seguinte:</p>

<ul>
<li><strong><code>campos</code></strong> - deve responder com o nome do campo no topo do JSON. No caso do banco de dados usado, deve responder com <code>"dados"</code>.</li>
<li><p><strong><code>campos &lt;subcampo&gt;</code></strong> - deve responder com os nomes dos campos existentes imediatamente apÃÂ³s o campo <code>&lt;subcampo&gt;</code>. Por exemplo, para <code>campos dados</code>, ele deve responder <code>id idLegislatura nome siglaPartido siglaUf uri uriPartido urlFoto</code>. Exemplo de obtenÃÂ§ÃÂ£o dos dados em Python:</p>

<pre><code>    # Exemplo para `campos dados`(`campos &lt;subcampo&gt;`)
    print(bd['dados'][0].keys())
</code></pre></li>
<li><p><strong><code>dados</code></strong> - deve retornar todos os dados no maior nÃÂ­vel do JSON (ou seja, todos o dados do banco)</p></li>
<li><strong><code>dados &lt;subcampo&gt;</code></strong> - deve retornar os dados associados ao nome do campo <code>&lt;subcampo&gt;</code>. Por exemplo, para <code>dados dados/id</code> deve retornar o id de todos os deputados.</li>
<li><strong><code>dados &lt;subcampo&gt; num &lt;num&gt;</code></strong> - o mesmo do anterior, mas deve retornar o dado associada ÃÂ  entrada de nÃÂºmero <code>&lt;num&gt;</code>.</li>
<li><strong><code>dados &lt;subcampo&gt; conteudo &lt;cont&gt;</code></strong> - deve retornar os dados associados ao subcampo, e que iniciem com o texto <code>&lt;cont&gt;</code>. Por exemplo, <code>dados dados/nome conteudo AB</code> deve retornar todos os nomes de deputados que inicial com "AB".</li>
<li><code>fechar</code> - termina a conversa com o servidor.</li>
<li><strong><code>quantos &lt;comando&gt;</code></strong> - retorno o nÃÂºmero de respostas (sem o conteudo) na execuÃÂ§ÃÂ£o do comando <code>&lt;comando&gt;</code>.</li>
</ul>

<p>Todas as mensagens sÃÂ£o textuais e usam um caracter de novalinha <code>\n</code> ao final. No final de cada resposta, os servidor deve responder com uma mensagem <code>OK\n</code>.</p>

<p>Fique a vontade para corrigir inconsistÃÂªncias do protocolo como bem entender. Implemente as funcionalidades aos poucos.</p>

<h2>Roteiro de Atividades</h2>

<ol>
<li>Implemente o seu servidor, testando-o com um cliente <code>nc</code>. Inicie apenas implementando a troca de mensagens (garantindo que o servidor interpretarÃÂ¡ corretamente as mensagens). Depois implemente as consultas propriamente ditas no seu cÃÂ³digo e as respostas. <strong>SugestÃÂ£o:</strong> faÃÂ§a isso para cada tipo de mensagem.</li>
<li>Teste o comportamento do seu servidor, quando ocorre um problema na comunicaÃÂ§ÃÂ£o. Procure tratar todos esses problemas no seu protocolo.</li>
</ol>

<h1>RelatÃÂ³rio</h1>

<p>A entrega do relatÃÂ³rio deve ser pelo github classroom, com o qual vocÃÂªs terÃÂ£o uma ÃÂ¡rea indicada a partir de email enviado para vocÃÂªs. Esse relatÃÂ³rio deve ser entregue em atÃÂ© 7 dias.</p>

<p>Todos os arquivos colocados no github devem estar codificados em <code>UTF-8</code> e devem ser arquivos de texto, seguindo a seguinte estrutura</p>

<pre><code>    README.md     - deve conter uma linha com o seu nome
    Lab2.3B/     - diretÃÂ³rio com o(s) cÃÂ³digo(s) produzido neste laboratÃÂ³rio
</code></pre>

<p></xmp></p>

<script src="https://strapdownjs.com/v/0.2/strapdown.js"></script>

<p></html></p>
